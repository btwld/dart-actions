name: "Coverage Comment"

on:
  workflow_call:
    inputs:
      coverage_file:
        description: "Path to the coverage file (lcov.info)"
        required: false
        default: "coverage/lcov.info"
        type: string
      min_coverage_threshold:
        description: "Minimum coverage percentage threshold"
        required: false
        default: 80
        type: number
      comment_header:
        description: "Header used for the sticky PR comment"
        required: false
        default: "coverage-analysis"
        type: string

jobs:
  coverage-comment:
    name: Analyze Coverage and Comment
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check if coverage file exists
        id: check_coverage
        run: |
          if [ -f "${{ inputs.coverage_file }}" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Coverage file ${{ inputs.coverage_file }} not found"
          fi

      - name: Parse coverage and generate comment
        if: steps.check_coverage.outputs.exists == 'true'
        id: parse_coverage
        run: |
          # Create a Python script to parse lcov.info and calculate coverage
          cat > parse_coverage.py << 'EOF'
          import re
          import sys
          from pathlib import Path

          def parse_lcov_file(file_path):
              """Parse lcov.info file and return coverage data"""
              coverage_data = {}
              current_file = None
              
              with open(file_path, 'r') as f:
                  for line in f:
                      line = line.strip()
                      
                      # File entry
                      if line.startswith('SF:'):
                          current_file = line[3:]  # Remove 'SF:' prefix
                          coverage_data[current_file] = {
                              'lines_found': 0,
                              'lines_hit': 0,
                              'functions_found': 0,
                              'functions_hit': 0,
                              'branches_found': 0,
                              'branches_hit': 0
                          }
                      
                      # Line coverage
                      elif line.startswith('LF:') and current_file:
                          coverage_data[current_file]['lines_found'] = int(line[3:])
                      elif line.startswith('LH:') and current_file:
                          coverage_data[current_file]['lines_hit'] = int(line[3:])
                      
                      # Function coverage
                      elif line.startswith('FNF:') and current_file:
                          coverage_data[current_file]['functions_found'] = int(line[4:])
                      elif line.startswith('FNH:') and current_file:
                          coverage_data[current_file]['functions_hit'] = int(line[4:])
                      
                      # Branch coverage
                      elif line.startswith('BRF:') and current_file:
                          coverage_data[current_file]['branches_found'] = int(line[4:])
                      elif line.startswith('BRH:') and current_file:
                          coverage_data[current_file]['branches_hit'] = int(line[4:])
              
              return coverage_data

          def calculate_file_coverage(file_data):
              """Calculate coverage percentage for a file"""
              if file_data['lines_found'] == 0:
                  return 0.0
              return (file_data['lines_hit'] / file_data['lines_found']) * 100

          def calculate_overall_coverage(coverage_data):
              """Calculate overall coverage percentage"""
              total_lines_found = sum(data['lines_found'] for data in coverage_data.values())
              total_lines_hit = sum(data['lines_hit'] for data in coverage_data.values())
              
              if total_lines_found == 0:
                  return 0.0
              return (total_lines_hit / total_lines_found) * 100

          def generate_comment(coverage_data, overall_coverage, threshold):
              """Generate markdown comment with coverage details"""
              comment = f"""## 📊 Code Coverage Analysis

          **Overall Coverage: {overall_coverage:.1f}%** {'❌' if overall_coverage < threshold else '✅'}

          The overall coverage is {'below' if overall_coverage < threshold else 'at or above'} the {threshold}% threshold.

          ### Per-File Coverage Details

          | File | Coverage | Lines Hit/Total |
          |------|----------|-----------------|"""

              # Sort files by coverage percentage (lowest first)
              sorted_files = sorted(
                  coverage_data.items(),
                  key=lambda x: calculate_file_coverage(x[1])
              )

              for file_path, data in sorted_files:
                  coverage_pct = calculate_file_coverage(data)
                  status_emoji = '🔴' if coverage_pct < 50 else '🟡' if coverage_pct < 80 else '🟢'
                  
                  # Make file path relative and more readable
                  relative_path = file_path.replace(str(Path.cwd()) + '/', '')
                  
                  comment += f"\n| `{relative_path}` | {coverage_pct:.1f}% {status_emoji} | {data['lines_hit']}/{data['lines_found']} |"

              comment += f"""

          ### Coverage Legend
          - 🟢 80%+ coverage
          - 🟡 50-79% coverage  
          - 🔴 <50% coverage

          **Note:** This analysis is based on line coverage from the lcov.info file.
          """

              return comment

          if __name__ == "__main__":
              lcov_file = sys.argv[1]
              threshold = float(sys.argv[2])
              
              try:
                  coverage_data = parse_lcov_file(lcov_file)
                  overall_coverage = calculate_overall_coverage(coverage_data)
                  comment = generate_comment(coverage_data, overall_coverage, threshold)
                  
                  # Output results for GitHub Actions
                  print(f"overall_coverage={overall_coverage:.1f}")
                  print(f"below_threshold={'true' if overall_coverage < threshold else 'false'}")
                  
                  # Write comment to file for GitHub Actions
                  with open('coverage_comment.md', 'w') as f:
                      f.write(comment)
                      
              except Exception as e:
                  print(f"Error parsing coverage: {e}")
                  sys.exit(1)
          EOF

          # Run the Python script
          python3 parse_coverage.py "${{ inputs.coverage_file }}" ${{ inputs.min_coverage_threshold }}

      - name: Comment on PR if coverage is below threshold
        if: steps.check_coverage.outputs.exists == 'true' && steps.parse_coverage.outputs.below_threshold == 'true'
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: ${{ inputs.comment_header }}
          message: file://coverage_comment.md

      - name: Remove comment if coverage is above threshold
        if: steps.check_coverage.outputs.exists == 'true' && steps.parse_coverage.outputs.below_threshold == 'false'
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: ${{ inputs.comment_header }}
          delete: true

      - name: Summary
        if: always()
        run: |
          if [ "${{ steps.check_coverage.outputs.exists }}" == "true" ]; then
            echo "## Coverage Analysis Summary" >> $GITHUB_STEP_SUMMARY
            echo "- Coverage file: ${{ inputs.coverage_file }}" >> $GITHUB_STEP_SUMMARY
            echo "- Overall coverage: ${{ steps.parse_coverage.outputs.overall_coverage }}%" >> $GITHUB_STEP_SUMMARY
            echo "- Threshold: ${{ inputs.min_coverage_threshold }}%" >> $GITHUB_STEP_SUMMARY
            echo "- Below threshold: ${{ steps.parse_coverage.outputs.below_threshold }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "## Coverage Analysis Summary" >> $GITHUB_STEP_SUMMARY
            echo "❌ Coverage file not found: ${{ inputs.coverage_file }}" >> $GITHUB_STEP_SUMMARY
          fi
