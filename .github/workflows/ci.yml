name: Flutter CI

on:
  workflow_call:
    inputs:
      min_coverage:
        description: "Minimum code coverage percentage required"
        required: false
        default: 80
        type: number
      project_paths:
        description: "List of project paths to run dependencies and tests (comma-separated)"
        required: false
        default: ""
        type: string

concurrency:
  group: flutter-ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  test:
    name: Run Flutter Tests
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    strategy:
      fail-fast: false
      matrix:
        project_path: ${{ fromJson(inputs.project_paths != '' && format('["{0}"]', join(split(inputs.project_paths, ','), '","')) || '["."]') }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: stable
          cache: true

      - name: Install dependencies
        run: |
          echo "Installing dependencies for project path: ${{ matrix.project_path }}"
          cd "${{ matrix.project_path }}" && flutter pub get

      - name: Analyze project
        run: |
          echo "Analyzing project path: ${{ matrix.project_path }}"
          flutter analyze "${{ matrix.project_path }}"

      - name: Install DCM
        uses: CQLabs/setup-dcm@v2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Run DCM
        run: dcm analyze "${{ matrix.project_path }}"
        shell: bash

      - name: Run tests
        run: |
          echo "Running tests for project path: ${{ matrix.project_path }}"
          flutter test --no-pub --coverage "${{ matrix.project_path }}"

      - name: Setup LCOV
        uses: hrishikesh-kadam/setup-lcov@v1
        with:
          ref: v2.3

      - name: Analyze Coverage
        run: |
          echo "üìä Analyzing code coverage for ${{ matrix.project_path }}..."

          COVERAGE_FILE="${{ matrix.project_path }}/coverage/lcov.info"
          if [ ! -f "$COVERAGE_FILE" ]; then
            echo "‚ùå Coverage file not found at $COVERAGE_FILE"
            exit 1
          fi

          # Parse lcov file and calculate coverage
          python3 << 'EOF'
          import re
          import sys
          import os

          project_path = os.environ.get("PROJECT_PATH", ".")
          lcov_file = os.path.join(project_path, "coverage", "lcov.info")
          min_coverage = float(os.environ.get('MIN_COVERAGE', '80'))

          # Define dynamic status thresholds
          # üü¢: >= min_coverage
          # üü°: >= (min_coverage * 0.625) and < min_coverage
          # üî¥: < (min_coverage * 0.625)
          yellow_threshold = min_coverage * 0.625

          def parse_lcov_file(file_path):
              coverage_data = {}
              total_lines = 0
              total_hit = 0

              try:
                  with open(file_path, 'r') as f:
                      content = f.read()
              except FileNotFoundError:
                  print(f"‚ùå Coverage file not found: {file_path}")
                  sys.exit(1)
              except Exception as e:
                  print(f"‚ùå Error reading coverage file: {e}")
                  sys.exit(1)

              file_sections = re.split(r'^SF:', content, flags=re.MULTILINE)

              for section in file_sections[1:]:
                  lines = section.strip().split('\n')
                  if not lines:
                      continue

                  file_path = lines[0].strip()
                  if not file_path:
                      continue

                  hit_lines = 0
                  total_file_lines = 0

                  for line in lines:
                      if line.startswith('DA:'):
                          parts = line[3:].split(',')
                          if len(parts) == 2:
                              _, hit_count = parts
                              total_file_lines += 1
                              if int(hit_count) > 0:
                                  hit_lines += 1

                  if total_file_lines > 0:
                      coverage_percentage = (hit_lines / total_file_lines) * 100
                      coverage_data[file_path] = {
                          'hit': hit_lines,
                          'total': total_file_lines,
                          'percentage': coverage_percentage
                      }
                      total_hit += hit_lines
                      total_lines += total_file_lines

              return coverage_data, total_hit, total_lines

          def get_coverage_status(percentage):
              if percentage >= min_coverage:
                  return "üü¢"
              elif percentage >= yellow_threshold:
                  return "üü°"
              else:
                  return "üî¥"

          coverage_data, total_hit, total_lines = parse_lcov_file(lcov_file)

          if total_lines == 0:
              print("‚ùå No coverage data found in lcov.info file")
              sys.exit(1)

          overall_coverage = (total_hit / total_lines) * 100

          print(f"\nüìä Code Coverage Analysis for {project_path}")
          print(f"{'='*50}")
          print(f"Overall Coverage: {overall_coverage:.1f}% {get_coverage_status(overall_coverage)}")
          print(f"Total Lines: {total_hit}/{total_lines}")
          print(f"Minimum Required: {min_coverage}%")

          if overall_coverage < min_coverage:
              print(f"\n‚ùå Coverage {overall_coverage:.1f}% is below minimum required {min_coverage}%")
              coverage_status = "FAILED"
          else:
              print(f"\n‚úÖ Coverage {overall_coverage:.1f}% meets minimum requirement {min_coverage}%")
              coverage_status = "PASSED"

          print(f"\nüìã Per-File Coverage Details")
          print(f"{'='*50}")
          print(f"{'File':<50} {'Coverage':<10} {'Lines Hit/Total':<15} {'Status'}")
          print(f"{'-'*50} {'-'*10} {'-'*15} {'-'*6}")

          sorted_files = sorted(coverage_data.items(), key=lambda x: x[1]['percentage'])

          for file_path, data in sorted_files:
              display_path = file_path
              if len(display_path) > 47:
                  display_path = "..." + display_path[-44:]
              status = get_coverage_status(data['percentage'])
              print(f"{display_path:<50} {data['percentage']:>6.1f}% {data['hit']:>3}/{data['total']:<3} {status}")

          print(f"\nüìà Coverage Legend:")
          print(f"üü¢ {min_coverage:.1f}%+ coverage")
          print(f"üü° {yellow_threshold:.1f}% - {min_coverage-0.1:.1f}% coverage")
          print(f"üî¥ <{yellow_threshold:.1f}% coverage")

          if coverage_status == "FAILED":
              sys.exit(1)
          EOF
        env:
          MIN_COVERAGE: ${{ inputs.min_coverage }}
          PROJECT_PATH: ${{ matrix.project_path }}