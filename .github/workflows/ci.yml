name: Flutter CI

on:
  workflow_call:
    inputs:
      min_coverage:
        description: "Minimum code coverage percentage required"
        required: false
        default: 80
        type: number
      project_paths:
        description: "List of project paths to run dependencies and tests (comma-separated)"
        required: false
        default: ""
        type: string

concurrency:
  group: flutter-ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  test:
    name: Run Flutter Tests
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    strategy:
      fail-fast: false

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: stable
          cache: true

      - name: Install dependencies
        run: |
          if [ -n "${{ inputs.project_paths }}" ]; then
            echo "Installing dependencies for specified project paths: ${{ inputs.project_paths }}"
            IFS=',' read -ra PATHS <<< "${{ inputs.project_paths }}"
            for path in "${PATHS[@]}"; do
              echo "Installing dependencies for project path: $path"
              cd "$path" && flutter pub get && cd - > /dev/null
            done
          else
            echo "Installing root dependencies"
            flutter pub get
          fi

      - name: Analyze root project
        run: flutter analyze

      - name: Install DCM
        uses: CQLabs/setup-dcm@v2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Run DCM
        run: dcm analyze .
        shell: bash

      - name: Run root tests
        run: |
          if [ -n "${{ inputs.project_paths }}" ]; then
            echo "Running tests on specified project paths: ${{ inputs.project_paths }}"
            IFS=',' read -ra PATHS <<< "${{ inputs.project_paths }}"
            for path in "${PATHS[@]}"; do
              echo "Testing project path: $path"
              flutter test --no-pub --coverage "$path"
            done
          else
            echo "Running all tests"
            flutter test --no-pub --coverage
          fi

      - name: Setup LCOV
        uses: hrishikesh-kadam/setup-lcov@v1
        with:
          ref: v2.3

      - name: Analyze Coverage
        run: |
          echo "üìä Analyzing code coverage..."
          
          if [ ! -f "coverage/lcov.info" ]; then
            echo "‚ùå Coverage file not found at coverage/lcov.info"
            exit 1
          fi
          
          # Parse lcov file and calculate coverage
          python3 << 'EOF'
          import re
          import sys
          from pathlib import Path
          
          def parse_lcov_file(file_path):
              """Parse lcov.info file and return coverage data"""
              coverage_data = {}
              total_lines = 0
              total_hit = 0
              
              try:
                  with open(file_path, 'r') as f:
                      content = f.read()
              except FileNotFoundError:
                  print(f"‚ùå Coverage file not found: {file_path}")
                  sys.exit(1)
              except Exception as e:
                  print(f"‚ùå Error reading coverage file: {e}")
                  sys.exit(1)
              
              # Split into file sections
              file_sections = re.split(r'^SF:', content, flags=re.MULTILINE)
              
              for section in file_sections[1:]:  # Skip first empty section
                  lines = section.strip().split('\n')
                  if not lines:
                      continue
                      
                  file_path = lines[0].strip()
                  if not file_path:
                      continue
                  
                  # Extract line coverage data
                  hit_lines = 0
                  total_file_lines = 0
                  
                  for line in lines:
                      if line.startswith('DA:'):
                          # Format: DA:line_number,hit_count
                          parts = line[3:].split(',')
                          if len(parts) == 2:
                              line_num, hit_count = parts
                              total_file_lines += 1
                              if int(hit_count) > 0:
                                  hit_lines += 1
                  
                  if total_file_lines > 0:
                      coverage_percentage = (hit_lines / total_file_lines) * 100
                      coverage_data[file_path] = {
                          'hit': hit_lines,
                          'total': total_file_lines,
                          'percentage': coverage_percentage
                      }
                      total_hit += hit_lines
                      total_lines += total_file_lines
              
              return coverage_data, total_hit, total_lines
          
          def get_coverage_status(percentage):
              """Get status emoji based on coverage percentage"""
              if percentage >= 80:
                  return "üü¢"
              elif percentage >= 50:
                  return "üü°"
              else:
                  return "üî¥"
          
          # Parse coverage data
          coverage_data, total_hit, total_lines = parse_lcov_file('coverage/lcov.info')
          
          if total_lines == 0:
              print("‚ùå No coverage data found in lcov.info file")
              sys.exit(1)
          
          # Calculate overall coverage
          overall_coverage = (total_hit / total_lines) * 100
          
          # Get minimum coverage from environment variable
          import os
          min_coverage = float(os.environ.get('MIN_COVERAGE', '80'))
          
          # Print header
          print(f"\nüìä Code Coverage Analysis")
          print(f"{'='*50}")
          print(f"Overall Coverage: {overall_coverage:.1f}% {get_coverage_status(overall_coverage)}")
          print(f"Total Lines: {total_hit}/{total_lines}")
          print(f"Minimum Required: {min_coverage}%")
          
          # Check if coverage meets minimum requirement
          if overall_coverage < min_coverage:
              print(f"\n‚ùå Coverage {overall_coverage:.1f}% is below minimum required {min_coverage}%")
              coverage_status = "FAILED"
          else:
              print(f"\n‚úÖ Coverage {overall_coverage:.1f}% meets minimum requirement {min_coverage}%")
              coverage_status = "PASSED"
          
          # Print per-file coverage
          print(f"\nüìã Per-File Coverage Details")
          print(f"{'='*50}")
          print(f"{'File':<50} {'Coverage':<10} {'Lines Hit/Total':<15} {'Status'}")
          print(f"{'-'*50} {'-'*10} {'-'*15} {'-'*6}")
          
          # Sort files by coverage percentage (lowest first)
          sorted_files = sorted(coverage_data.items(), key=lambda x: x[1]['percentage'])
          
          for file_path, data in sorted_files:
              # Truncate long file paths for display
              display_path = file_path
              if len(display_path) > 47:
                  display_path = "..." + display_path[-44:]
              
              status = get_coverage_status(data['percentage'])
              print(f"{display_path:<50} {data['percentage']:>6.1f}% {data['hit']:>3}/{data['total']:<3} {status}")
          
          print(f"\nüìà Coverage Legend:")
          print(f"üü¢ 80%+ coverage")
          print(f"üü° 50-79% coverage")
          print(f"üî¥ <50% coverage")
          
          # Exit with error code if coverage is below minimum
          if coverage_status == "FAILED":
              sys.exit(1)
          EOF
        env:
          MIN_COVERAGE: ${{ inputs.min_coverage }}

      